#' Retrieve the stanfit object generated by rstan.
#' This object can be used with any other function or package that uses rstan objects
#' @param bpc_object a bpc object
#' @return a stanfit object
#' @export
#'
#' @examples
#' m<-bpc(data = tennis_agresti, player0 = 'player0',player1 = 'player1',result_column = 'y',model_type = 'bt', solve_ties = 'none')
#' stanfit<- get_stanfit(m)
#' print(class(stanfit))
get_stanfit<-function(bpc_object){
  if(class(bpc_object)!='bpc')
    stop('Error! The object is not of bpc class')
  return(bpc_object$stanfit)
}

#' Get the posterior samples for a parameter of the model.
#' @param bpc_object a bpc object
#' @param n how many times are we sampling? Default 1000
#' @param par name of the parameters to predict
#' @return Return a data frame with the posterior samples for the parameters. One column for each parameter one row for each sample
#' @export
#'
#' @examples
#' m<-bpc(data = tennis_agresti, player0 = 'player0',player1 = 'player1',result_column = 'y',model_type = 'bt', solve_ties = 'none')
#' s <- sample_posterior(m, par='lambda', n=100)
#' print(head(s))
sample_posterior<-function(bpc_object, par='lambda', n=1000){
  #TODO: verify the predictors condition
  if(class(bpc_object)!='bpc')
    stop('Error! The object is not of bpc class')

  n<-floor(n)
  cluster_lookup_table <- bpc_object$cluster_lookup_table
  lookup_table <- bpc_object$lookup_table

  stanfit<- get_stanfit(bpc_object)
  posterior <- as.data.frame(sample_stanfit(stanfit, par=par,n=n))

  #Creating parameter name for the columns
  # The challenge here is to present a data frame with the appropriate variable names in the order given by stan.
  # We do this with the function below from helpers indexes
  colnames(posterior) <- create_array_of_par_names(par,lookup_table=lookup_table, cluster_lookup_table = cluster_lookup_table)
  return(as.data.frame(posterior))
}

#' Return a data frame with the mean and with high and low 95% hpd interval for all parameters of the model
#' @param bpc_object a bpc object
#' @return a data frame containing a column with the parameters, a column with mean and two columns with higher and lower hpdi
#' @export
#'
#' @examples
#' m<-bpc(data = tennis_agresti, player0 = 'player0',player1 = 'player1',result_column = 'y',model_type = 'bt', solve_ties = 'none')
#' hpdi<-get_hpdi_parameters(m)
#' print(hpdi)
get_hpdi_parameters<-function(bpc_object){
  #TODO: verify the predictors condition
  if(class(bpc_object)!='bpc')
    stop('Error! The object is not of bpc class')
  hpdi<-bpc_object$hpdi
  #excluding some parameters that are not used
  hpdi <- dplyr::filter(hpdi, !stringr::str_detect(Parameter, "log_lik"))
  hpdi <- dplyr::filter(hpdi, !stringr::str_detect(Parameter, "lp__"))
  pars<-get_model_parameters(bpc_object)
  for(i in 1:length(pars)){
    parameter <- pars[i]
    if(parameter=='U'){
      hpdi<-replace_parameter_index_with_names(hpdi,column = 'Parameter',par = parameter, lookup_table=bpc_object$lookup_table, cluster_lookup_table = bpc_object$cluster_lookup_table)
    }
    else if(parameter=='lambda'){
      hpdi<-replace_parameter_index_with_names(hpdi, column = 'Parameter',par=parameter,lookup_table=bpc_object$lookup_table)
    }
    else if(parameter=='B'){
      hpdi<-replace_parameter_index_with_names(hpdi, column = 'Parameter',par=parameter,lookup_table=bpc_object$lookup_table, predictors_lookup_table=bpc_object$predictors_lookup_table)
    }
  }
  return(hpdi)
}



#' Generate a ranking of the ability based on sampling the posterior distribution of the ranks
#' To print this object you should remove the last column PosteriorRank since it contain the whole posterior distribution for each case
#' @param bpc_object a bpc object
#' @param n Number of times we will sample the posterior
#' @return a data frame. This data frame contains the median of the rank, the mean, the standard deviation and column with a list containing all the posterior values for the rank
#' @export
#'
#' @examples
#' m<-bpc(data = tennis_agresti, player0 = 'player0',player1 = 'player1',result_column = 'y',model_type = 'bt', solve_ties = 'none')
#' rank_m<-rank_parameters(m,n=100)
#' rank_table <- dplyr::select(rank_m,-MeanRank, -StadRank,-PosteriorRank)
#' print(rank_table)
rank_players<-function(bpc_object,n=1000){
  if(class(bpc_object)!='bpc')
    stop('Error! The object is not of bpc class')
  s<-sample_posterior(bpc_object,par='lambda',n=n)
  s <- dplyr::mutate(s, rown = dplyr::row_number())
  wide_s <- tidyr::pivot_longer(s, cols=tidyselect::starts_with('lambda'), names_to = "Parameter", values_to = "value")
  rank_df <- wide_s %>%
    dplyr::group_by(rown) %>%
    dplyr::mutate(Rank = rank(-value, ties.method = 'random')) %>%
    dplyr::ungroup() %>%
    dplyr::select(-value) %>%
    dplyr::group_by(Parameter) %>%
    dplyr::summarise(MedianRank = median(Rank),
                     MeanRank = mean(Rank),
                     StdRank = sqrt(var(Rank)),
                     PosteriorRank = list(rank=Rank)) %>%
    dplyr::arrange(MedianRank)
  return(rank_df)
}


#' Tiny wrapper for the PSIS-LOO-CV method from the loo package
#' This is used to evaluate the fit of the model using entropy criteria
#' @references
#' Vehtari A, Gelman A, Gabry J (2017). “Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC.” _Statistics and Computing_, *27*, 1413-1432. doi:10.1007/s11222-016-9696-4 (URL: https://doi.org/10.1007/s11222-016-9696-4).
#' @param bpc_object a bpc object
#' @return a loo object
#' @export
#'
#' @examples
#'  m<-bpc(data = tennis_agresti, player0 = 'player0',player1 = 'player1',result_column = 'y',model_type = 'bt', solve_ties = 'none')
#'  l<-get_loo(m)
#' print(l)
get_loo<-function(bpc_object){
  if(class(bpc_object)!='bpc')
    stop('Error! The object is not of bpc class')
  l<-loo::loo(get_stanfit(bpc_object), pars = "log_lik")
  return(l)
}

#' Tiny wrapper for the WAIC method from the loo package
#' This is used to evaluate the fit of the model using the Watanabe-Akaike Information criteria
#' @references
#' Gelman, Andrew, Jessica Hwang, and Aki Vehtari. "Understanding predictive information criteria for Bayesian models." Statistics and computing 24.6 (2014): 997-1016.
#' @param bpc_object a bpc object
#' @return a loo object
#' @export
#'
#' @examples
#' m<-bpc(data = tennis_agresti, player0 = 'player0',player1 = 'player1',result_column = 'y',model_type = 'bt', solve_ties = 'none')
#' waic<-get_waic(m)
#' print(waic)
get_waic <- function(bpc_object){
  if(class(bpc_object)!='bpc')
    stop('Error! The object is not of bpc class')
  loglik<-loo::extract_log_lik(get_stanfit(bpc_object))
  waic<-loo::waic(loglik)
  return(waic)
}

#' Tiny wrapper to launch a shinystan app to investigate the MCMC
#' It launches a shinystan app automatically in the web browser
#' @param bpc_object a bpc object
#' @return
#' @export
launch_shinystan<-function(bpc_object){
  if(class(bpc_object)!='bpc')
    stop('Error! The object is not of bpc class')
  shinystan::launch_shinystan(get_stanfit(bpc_object))
}
